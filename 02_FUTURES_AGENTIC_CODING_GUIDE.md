# ğŸ› ï¸ Binance Futures AI ì‹œìŠ¤í…œ ì—ì´ì „í‹± ì½”ë”© ê°€ì´ë“œ

[![Agentic Coding](https://img.shields.io/badge/Agentic%20Coding-Verified%20Development-blue.svg)](https://github.com/your-repo)
[![Phase Based](https://img.shields.io/badge/Development-10%20Phase%20Structure-green.svg)](https://github.com/your-repo)
[![Test Driven](https://img.shields.io/badge/Approach-Test%20Driven-orange.svg)](https://github.com/your-repo)

> **ê²€ì¦ ê¸°ë°˜ ì²´ê³„ì  ê°œë°œ ë°©ë²•ë¡ **  
> ì„ ë¬¼ê±°ë˜ AI ì‹œìŠ¤í…œì„ ìœ„í•œ ë‹¨ê³„ë³„ êµ¬í˜„ ë° ê²€ì¦ ê°€ì´ë“œ

---

## ğŸ¯ ì—ì´ì „í‹± ì½”ë”©ì´ë€?

**ì—ì´ì „í‹± ì½”ë”©(Agentic Coding)**ì€ AI ì—ì´ì „íŠ¸ì²˜ëŸ¼ ì‘ë™í•˜ëŠ” ì²´ê³„ì  ê°œë°œ ë°©ë²•ë¡ ì…ë‹ˆë‹¤.

### ğŸ”¥ í•µì‹¬ ì›ì¹™

1. **ğŸ“‹ Phase ê¸°ë°˜ êµ¬ì¡°**: 10ë‹¨ê³„ë¡œ ë‚˜ëˆ„ì–´ ìˆœì°¨ì  ê°œë°œ
2. **âœ… ê²€ì¦ ìš°ì„ **: ê° ë‹¨ê³„ë§ˆë‹¤ ê¸°ëŠ¥ ê²€ì¦ í›„ ë‹¤ìŒ ë‹¨ê³„ ì§„í–‰
3. **ğŸ”„ ì ì§„ì  ê°œì„ **: ì‘ì€ ë‹¨ìœ„ë¡œ ê°œë°œí•˜ê³  ì¦‰ì‹œ í…ŒìŠ¤íŠ¸
4. **ğŸ“ ì‹¤ì‹œê°„ ë¬¸ì„œí™”**: ëª¨ë“  ë³€ê²½ì‚¬í•­ì„ ì¦‰ì‹œ ê¸°ë¡
5. **ğŸ¯ ëª©í‘œ ì§€í–¥**: ê° Phaseë³„ ëª…í™•í•œ ì„±ê³µ ê¸°ì¤€ ì„¤ì •

### ğŸ’¡ ì™œ ì—ì´ì „í‹± ì½”ë”©ì¸ê°€?

| ê¸°ì¡´ ê°œë°œ ë°©ì‹ | **ì—ì´ì „í‹± ì½”ë”©** |
|-------------|-------------|
| í•œë²ˆì— ëª¨ë“  ê¸°ëŠ¥ êµ¬í˜„ | ë‹¨ê³„ë³„ ì ì§„ì  êµ¬í˜„ |
| ë§ˆì§€ë§‰ì— í†µí•© í…ŒìŠ¤íŠ¸ | ë§¤ ë‹¨ê³„ë§ˆë‹¤ ê²€ì¦ |
| ë¬¸ì„œí™” ë’¤ë¡œ ë¯¸ë£¸ | ì‹¤ì‹œê°„ ë¬¸ì„œí™” |
| ë²„ê·¸ ë°œê²¬ì´ ëŠ¦ìŒ | ì¡°ê¸° ë²„ê·¸ ë°œê²¬ ë° ìˆ˜ì • |

---

## ğŸ—ºï¸ 10ë‹¨ê³„ Phase ë¡œë“œë§µ

### ğŸ“Š Phase ê°œìš” ë° ìš°ì„ ìˆœìœ„

| Phase | ì œëª© | ì¤‘ìš”ë„ | ì˜ˆìƒ ì‹œê°„ | ì˜ì¡´ì„± |
|-------|------|--------|----------|---------|
| **Phase 1** | ê°œë°œ í™˜ê²½ ì„¤ì • | ğŸ”¥ğŸ”¥ğŸ”¥ | 2ì‹œê°„ | - |
| **Phase 2** | Binance Futures API ì—°ë™ | ğŸ”¥ğŸ”¥ğŸ”¥ | 3ì‹œê°„ | Phase 1 |
| **Phase 3** | AI ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ | ğŸ”¥ğŸ”¥ğŸ”¥ | 4ì‹œê°„ | Phase 2 |
| **Phase 4** | ë¡œìŠ¤ ì¹´ë©”ë¡  RSI ì „ëµ | ğŸ”¥ğŸ”¥ | 3ì‹œê°„ | Phase 3 |
| **Phase 5** | ê³ ê¸‰ ì„ ë¬¼ ê±°ë˜ ê¸°ëŠ¥ | ğŸ”¥ğŸ”¥ | 4ì‹œê°„ | Phase 4 |
| **Phase 6** | ë°±í…ŒìŠ¤íŒ… ë° ìµœì í™” | ğŸ”¥ğŸ”¥ | 5ì‹œê°„ | Phase 5 |
| **Phase 7** | ì›¹ ì¸í„°í˜ì´ìŠ¤ | ğŸ”¥ | 3ì‹œê°„ | Phase 6 |
| **Phase 8** | í…”ë ˆê·¸ë¨ ì•Œë¦¼ | ğŸ”¥ | 2ì‹œê°„ | Phase 7 |
| **Phase 9** | Vultr ì„œë²„ ë°°í¬ | ğŸ”¥ | 4ì‹œê°„ | Phase 8 |
| **Phase 10** | ê³ ê¸‰ ìë™í™” ë° ëª¨ë‹ˆí„°ë§ | ğŸ”¥ | 6ì‹œê°„ | Phase 9 |

**â±ï¸ ì´ ì˜ˆìƒ ì‹œê°„: 36ì‹œê°„ (4-5ì¼)**

---

## ğŸš€ Phase 1: ê°œë°œ í™˜ê²½ ì„¤ì •

### ğŸ¯ ëª©í‘œ
- Python 3.9+ í™˜ê²½ êµ¬ì¶•
- Freqtrade 2024.12+ ì„¤ì¹˜
- ì„ ë¬¼ê±°ë˜ ì „ìš© í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±

### ğŸ“‹ êµ¬í˜„ ë‹¨ê³„

#### 1.1 ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­ í™•ì¸
```bash
# Python ë²„ì „ í™•ì¸ (3.9+ í•„ìˆ˜)
python3 --version
# ì¶œë ¥ ì˜ˆì‹œ: Python 3.11.5

# ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ í™•ì¸ (ìµœì†Œ 4GB ê¶Œì¥)
free -h
# ì¶œë ¥ ì˜ˆì‹œ: Mem: 7.7Gi

# ì„ ë¬¼ ê±°ë˜ API ì—°ê²° í…ŒìŠ¤íŠ¸
curl -I https://fapi.binance.com/fapi/v1/ping
# ì¶œë ¥ ì˜ˆì‹œ: HTTP/2 200
```

#### 1.2 í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
```bash
# ìƒˆ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
mkdir binance-futures-freqtrade
cd binance-futures-freqtrade

# Python ê°€ìƒí™˜ê²½ ìƒì„±
python3 -m venv .venv
source .venv/bin/activate

# ê°€ìƒí™˜ê²½ í™œì„±í™” í™•ì¸
which python
# ì¶œë ¥: /path/to/binance-futures-freqtrade/.venv/bin/python
```

#### 1.3 Freqtrade ì„¤ì¹˜ ë° ê²€ì¦
```bash
# Freqtrade ì„¤ì¹˜ (Futures ì§€ì›)
pip install freqtrade[complete]

# ì„¤ì¹˜ í™•ì¸
freqtrade --version
# ì¶œë ¥ ì˜ˆì‹œ: freqtrade 2024.12

# FreqUI ì„¤ì¹˜
freqtrade install-ui

# ì„¤ì¹˜ í™•ì¸
ls -la ~/.freqtrade/
# ì¶œë ¥: freqUI ë””ë ‰í† ë¦¬ í™•ì¸
```

#### 1.4 í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±
```bash
# ì„ ë¬¼ê±°ë˜ ì „ìš© ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
mkdir -p user_data/{strategies,hyperopts,data,logs}
mkdir -p docs scripts tests monitoring deployment

# êµ¬ì¡° í™•ì¸
tree -L 2
```

### âœ… Phase 1 ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] Python 3.9+ ì„¤ì¹˜ ë° í™•ì¸
- [ ] ê°€ìƒí™˜ê²½ ìƒì„± ë° í™œì„±í™”
- [ ] Freqtrade ìµœì‹  ë²„ì „ ì„¤ì¹˜
- [ ] FreqUI ì„¤ì¹˜ ì™„ë£Œ
- [ ] í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
- [ ] Binance Futures API ì—°ê²° ê°€ëŠ¥

### ğŸš¨ Phase 1 ë¬¸ì œ í•´ê²°

**ë¬¸ì œ: Python ë²„ì „ì´ 3.9 ë¯¸ë§Œ**
```bash
# í•´ê²°ì±…: pyenvë¡œ Python ìµœì‹  ë²„ì „ ì„¤ì¹˜
curl https://pyenv.run | bash
pyenv install 3.11.5
pyenv global 3.11.5
```

**ë¬¸ì œ: Freqtrade ì„¤ì¹˜ ì‹¤íŒ¨**
```bash
# í•´ê²°ì±…: ì‹œìŠ¤í…œ ì˜ì¡´ì„± ì„¤ì¹˜
sudo apt-get update
sudo apt-get install python3-dev python3-pip build-essential
pip install --upgrade pip setuptools wheel
```

---

## ğŸ”Œ Phase 2: Binance Futures API ì—°ë™

### ğŸ¯ ëª©í‘œ
- Binance Testnet ê³„ì • ìƒì„± ë° API í‚¤ ì„¤ì •
- ì„ ë¬¼ê±°ë˜ ì „ìš© Freqtrade ì„¤ì •
- 72ê°œ Futures API ì—”ë“œí¬ì¸íŠ¸ ì—°ê²° í™•ì¸

### ğŸ“‹ êµ¬í˜„ ë‹¨ê³„

#### 2.1 Binance Testnet ê³„ì • ì„¤ì •
```bash
# 1. í…ŒìŠ¤íŠ¸ë„· ì ‘ì†
# URL: https://testnet.binancefuture.com/

# 2. GitHub OAuth ë¡œê·¸ì¸

# 3. í…ŒìŠ¤íŠ¸ ìê¸ˆ ì¶©ì „ (ë¬´ë£Œ USDT)
# ì›¹ì‚¬ì´íŠ¸ì—ì„œ "Get Test Funds" í´ë¦­

# 4. API í‚¤ ìƒì„±
# API Management > Create API Key
# Futures Trading ê¶Œí•œ í™œì„±í™”
```

#### 2.2 ì„ ë¬¼ê±°ë˜ ì„¤ì • íŒŒì¼ ìƒì„±
```bash
# ì„¤ì • íŒŒì¼ ìƒì„±
nano user_data/config_futures.json
```

```json
{
  "max_open_trades": 3,
  "stake_currency": "USDT",
  "stake_amount": "unlimited",
  "tradable_balance_ratio": 0.99,
  "fiat_display_currency": "USD",
  "dry_run": false,
  "dry_run_wallet": 10000,
  "trading_mode": "futures",
  "margin_mode": "isolated",
  "exchange": {
    "name": "binance",
    "key": "your_testnet_api_key",
    "secret": "your_testnet_api_secret",
    "sandbox": true,
    "ccxt_config": {
      "enableRateLimit": true,
      "sandbox": true,
      "urls": {
        "api": {
          "public": "https://testnet.binancefuture.com",
          "private": "https://testnet.binancefuture.com"
        }
      },
      "options": {
        "defaultType": "future"
      }
    }
  },
  "pairlists": [
    {
      "method": "StaticPairList",
      "pairs": ["BTCUSDT", "ETHUSDT", "ADAUSDT"]
    }
  ]
}
```

#### 2.3 API ì—°ê²° í…ŒìŠ¤íŠ¸
```bash
# ì„¤ì • ê²€ì¦
freqtrade test-pairlist --config user_data/config_futures.json

# ê³„ì¢Œ ì •ë³´ í™•ì¸
freqtrade show-trades --config user_data/config_futures.json

# ì„ ë¬¼ ê±°ë˜ ëª¨ë“œ í™•ì¸
freqtrade show-config --config user_data/config_futures.json | grep "trading_mode"
# ì¶œë ¥: "trading_mode": "futures"
```

#### 2.4 í•µì‹¬ API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
```python
# scripts/test_api_endpoints.py
import ccxt
import json

def test_binance_futures_api():
    """Binance Futures API ì—°ê²° í…ŒìŠ¤íŠ¸"""
    
    with open('user_data/config_futures.json', 'r') as f:
        config = json.load(f)
    
    exchange = ccxt.binance({
        'apiKey': config['exchange']['key'],
        'secret': config['exchange']['secret'],
        'sandbox': True,
        'options': {'defaultType': 'future'}
    })
    
    # í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
    tests = {
        'server_time': lambda: exchange.fetch_time(),
        'account_info': lambda: exchange.fetch_balance(),
        'positions': lambda: exchange.fetch_positions(),
        'tickers': lambda: exchange.fetch_ticker('BTCUSDT'),
        'funding_rate': lambda: exchange.fetch_funding_rate('BTCUSDT')
    }
    
    results = {}
    for test_name, test_func in tests.items():
        try:
            result = test_func()
            results[test_name] = "âœ… SUCCESS"
            print(f"{test_name}: âœ… SUCCESS")
        except Exception as e:
            results[test_name] = f"âŒ FAILED: {str(e)}"
            print(f"{test_name}: âŒ FAILED: {str(e)}")
    
    return results

if __name__ == "__main__":
    test_binance_futures_api()
```

### âœ… Phase 2 ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] Binance Testnet ê³„ì • ìƒì„±
- [ ] API í‚¤ ìƒì„± ë° Futures Trading ê¶Œí•œ í™•ì¸
- [ ] í…ŒìŠ¤íŠ¸ USDT ì¶©ì „ ì™„ë£Œ
- [ ] config_futures.json ì„¤ì • ì™„ë£Œ
- [ ] `trading_mode: futures` ì„¤ì • í™•ì¸
- [ ] API ì—°ê²° í…ŒìŠ¤íŠ¸ ì„±ê³µ
- [ ] í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸ ì‘ë‹µ í™•ì¸

---

## ğŸ¤– Phase 3: AI ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ

### ğŸ¯ ëª©í‘œ
- ë ˆë²„ë¦¬ì§€ ê³ ë ¤ AI í¬ì§€ì…˜ ê³„ì‚° ì‹œìŠ¤í…œ êµ¬í˜„
- ë™ì  ë ˆë²„ë¦¬ì§€ ì¡°ì • ì•Œê³ ë¦¬ì¦˜ ê°œë°œ
- ì„ ë¬¼ê±°ë˜ ì „ìš© ë¦¬ìŠ¤í¬ ë§¤ê°œë³€ìˆ˜ ì„¤ì •

### ğŸ“‹ êµ¬í˜„ ë‹¨ê³„

#### 3.1 AI ë¦¬ìŠ¤í¬ ê¸°ë³¸ ì „ëµ í´ë˜ìŠ¤ ìƒì„±
```python
# user_data/strategies/FuturesAIRiskStrategy.py
import freqtrade.vendor.qtpylib.indicators as qtpylib
import numpy as np
import pandas as pd
from freqtrade.strategy import IStrategy, IntParameter, DecimalParameter
import talib.abstract as ta

class FuturesAIRiskStrategy(IStrategy):
    """ì„ ë¬¼ê±°ë˜ ì „ìš© AI ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì „ëµ"""
    
    # ì „ëµ ë©”íƒ€ë°ì´í„°
    INTERFACE_VERSION = 3
    timeframe = '15m'
    can_short = True  # ìˆ í¬ì§€ì…˜ í™œì„±í™”
    
    # ì„ ë¬¼ê±°ë˜ ì „ìš© ë§¤ê°œë³€ìˆ˜
    minimal_roi = {"0": 0.05, "30": 0.03, "60": 0.01, "120": 0}
    stoploss = -0.05  # 5% ìŠ¤íƒ‘ë¡œìŠ¤
    
    # AI ë¦¬ìŠ¤í¬ ë§¤ê°œë³€ìˆ˜
    risk_percentage = DecimalParameter(0.5, 2.0, default=1.0, space="buy")
    max_leverage = IntParameter(1, 10, default=5, space="buy")
    volatility_threshold = DecimalParameter(0.02, 0.08, default=0.04, space="buy")
    
    def populate_indicators(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """ì„ ë¬¼ê±°ë˜ íŠ¹í™” ì§€í‘œ ìƒì„±"""
        
        # ê¸°ë³¸ ì§€í‘œ
        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)
        dataframe['ema_fast'] = ta.EMA(dataframe, timeperiod=12)
        dataframe['ema_slow'] = ta.EMA(dataframe, timeperiod=26)
        
        # ë³€ë™ì„± ì§€í‘œ (ë ˆë²„ë¦¬ì§€ ê³„ì‚°ìš©)
        dataframe['atr'] = ta.ATR(dataframe, timeperiod=14)
        dataframe['volatility'] = dataframe['atr'] / dataframe['close']
        
        # ë³¼ë¦°ì €ë°´ë“œ
        bb = ta.BBANDS(dataframe, timeperiod=20, nbdevup=2, nbdevdn=2)
        dataframe['bb_upper'] = bb['upperband']
        dataframe['bb_lower'] = bb['lowerband']
        dataframe['bb_percent'] = (dataframe['close'] - dataframe['bb_lower']) / (dataframe['bb_upper'] - dataframe['bb_lower'])
        
        return dataframe
    
    def populate_entry_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """ì§„ì… ì‹ í˜¸ (ë¡±/ìˆ)"""
        
        # ë¡± ì§„ì… ì¡°ê±´
        dataframe.loc[
            (dataframe['rsi'] < 30) &
            (dataframe['close'] < dataframe['bb_lower']) &
            (dataframe['ema_fast'] > dataframe['ema_slow']),
            'enter_long'] = 1
        
        # ìˆ ì§„ì… ì¡°ê±´  
        dataframe.loc[
            (dataframe['rsi'] > 70) &
            (dataframe['close'] > dataframe['bb_upper']) &
            (dataframe['ema_fast'] < dataframe['ema_slow']),
            'enter_short'] = 1
            
        return dataframe
    
    def populate_exit_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """ì²­ì‚° ì‹ í˜¸"""
        
        # ë¡± ì²­ì‚°
        dataframe.loc[
            (dataframe['rsi'] > 60) |
            (dataframe['close'] > dataframe['bb_upper']),
            'exit_long'] = 1
        
        # ìˆ ì²­ì‚°
        dataframe.loc[
            (dataframe['rsi'] < 40) |
            (dataframe['close'] < dataframe['bb_lower']),
            'exit_short'] = 1
            
        return dataframe
```

#### 3.2 AI í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° êµ¬í˜„
```python
def custom_stake_amount(self, pair: str, current_time, current_rate: float, 
                       proposed_stake: float, min_stake: float, max_stake: float, 
                       entry_tag: str, side: str, **kwargs) -> float:
    """ì„ ë¬¼ê±°ë˜ ì „ìš© AI í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
    
    # í˜„ì¬ ì”ê³  ê°€ì ¸ì˜¤ê¸°
    balance = self.wallets.get_total_stake_amount()
    
    # ë³€ë™ì„± ê¸°ë°˜ ë¦¬ìŠ¤í¬ ì¡°ì •
    dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
    current_volatility = dataframe['volatility'].iloc[-1]
    
    # ë™ì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°
    optimal_leverage = self.calculate_optimal_leverage(current_volatility)
    
    # ë¦¬ìŠ¤í¬ ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
    risk_amount = balance * (self.risk_percentage.value / 100)
    effective_stop_distance = abs(self.stoploss) * optimal_leverage
    
    if effective_stop_distance > 0:
        position_size = risk_amount / effective_stop_distance
    else:
        position_size = min_stake
    
    # ìµœì†Œ/ìµœëŒ€ ì œí•œ ì ìš©
    position_size = max(min_stake, min(position_size, max_stake))
    
    self.logger.info(f"AI Position Calc - Pair: {pair}, Volatility: {current_volatility:.4f}, "
                    f"Leverage: {optimal_leverage}, Position: {position_size:.2f}")
    
    return position_size

def calculate_optimal_leverage(self, volatility: float) -> int:
    """ë³€ë™ì„± ê¸°ë°˜ ìµœì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°"""
    
    if volatility > 0.06:      # ì´ˆê³ ë³€ë™ì„± (>6%)
        return min(2, self.max_leverage.value)
    elif volatility > 0.04:    # ê³ ë³€ë™ì„± (4-6%)
        return min(3, self.max_leverage.value)
    elif volatility > 0.02:    # ì¤‘ë³€ë™ì„± (2-4%)
        return min(5, self.max_leverage.value)
    else:                      # ì €ë³€ë™ì„± (<2%)
        return min(8, self.max_leverage.value)

def leverage(self, pair: str, current_time, current_rate: float, 
            proposed_leverage: int, max_leverage: int, entry_tag: str, 
            side: str, **kwargs) -> float:
    """Freqtrade ë ˆë²„ë¦¬ì§€ ì½œë°±"""
    
    dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
    current_volatility = dataframe['volatility'].iloc[-1]
    
    return self.calculate_optimal_leverage(current_volatility)
```

#### 3.3 ë¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
```python
def custom_exit(self, pair: str, trade, current_time, current_rate: float,
               current_profit: float, **kwargs) -> str:
    """AI ê¸°ë°˜ ë™ì  ì²­ì‚° ê´€ë¦¬"""
    
    # ë§ˆì§„ ë¹„ìœ¨ í™•ì¸
    margin_ratio = self.get_margin_ratio(pair)
    if margin_ratio > 0.8:  # 80% ì´ìƒ ë§ˆì§„ ì‚¬ìš©ì‹œ
        return "margin_risk"
    
    # ë ˆë²„ë¦¬ì§€ ê¸°ë°˜ ì†ìµ í™•ì¸
    leverage = trade.leverage or 1
    effective_profit = current_profit * leverage
    
    # ê³ ë ˆë²„ë¦¬ì§€ í¬ì§€ì…˜ ë³´í˜¸
    if leverage >= 5 and current_profit < -0.02:  # 2% ì†ì‹¤
        return "high_leverage_protection"
    
    # ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ ê³ ë ¤
    funding_cost = self.get_funding_cost(pair, trade)
    if funding_cost > abs(current_profit) * 0.5:  # ìˆ˜ìˆ˜ë£Œê°€ ì†ìµì˜ 50% ì´ˆê³¼
        return "funding_cost_exit"
    
    return None

def get_margin_ratio(self, pair: str) -> float:
    """í˜„ì¬ ë§ˆì§„ ì‚¬ìš©ë¥  ê³„ì‚°"""
    try:
        positions = self.exchange._api.futures_account()
        for position in positions['positions']:
            if position['symbol'] == pair.replace('/', ''):
                maintenance_margin = float(position['maintMargin'])
                margin_balance = float(position['marginBalance'])
                if margin_balance > 0:
                    return maintenance_margin / margin_balance
        return 0.0
    except Exception:
        return 0.0
```

### âœ… Phase 3 ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] FuturesAIRiskStrategy í´ë˜ìŠ¤ ìƒì„±
- [ ] custom_stake_amount ë©”ì„œë“œ êµ¬í˜„
- [ ] ë™ì  ë ˆë²„ë¦¬ì§€ ê³„ì‚° ë¡œì§ ì™„ì„±
- [ ] ë³€ë™ì„± ê¸°ë°˜ ë¦¬ìŠ¤í¬ ì¡°ì • êµ¬í˜„
- [ ] ë§ˆì§„ ë¹„ìœ¨ ëª¨ë‹ˆí„°ë§ ê¸°ëŠ¥ ì¶”ê°€
- [ ] ë°±í…ŒìŠ¤íŒ…ìœ¼ë¡œ ë¦¬ìŠ¤í¬ ê³„ì‚° ê²€ì¦

### ğŸ§ª Phase 3 í…ŒìŠ¤íŠ¸
```bash
# AI ë¦¬ìŠ¤í¬ ì „ëµ ë°±í…ŒìŠ¤íŒ…
freqtrade backtesting \
  --config user_data/config_futures.json \
  --strategy FuturesAIRiskStrategy \
  --timerange 20241001-20241101 \
  --breakdown day
```

---

## ğŸ“ˆ Phase 4: ë¡œìŠ¤ ì¹´ë©”ë¡  RSI ì „ëµ

### ğŸ¯ ëª©í‘œ
- ë¡œìŠ¤ ì¹´ë©”ë¡ ì˜ RSI ë°˜ì „ ì „ëµì„ ì„ ë¬¼ê±°ë˜ì— ìµœì í™”
- ë¡±/ìˆ ì–‘ë°©í–¥ ì‹ í˜¸ ìƒì„± ì‹œìŠ¤í…œ êµ¬í˜„
- ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œë¥¼ ê³ ë ¤í•œ ì§„ì…/ì²­ì‚° ë¡œì§

### ğŸ“‹ êµ¬í˜„ ë‹¨ê³„

#### 4.1 ë¡œìŠ¤ ì¹´ë©”ë¡  ì „ëµ ê¸°ë³¸ êµ¬ì¡°
```python
# user_data/strategies/RossCameronFuturesStrategy.py
from freqtrade.strategy import IStrategy
import talib.abstract as ta
import pandas as pd

class RossCameronFuturesStrategy(FuturesAIRiskStrategy):
    """ë¡œìŠ¤ ì¹´ë©”ë¡  RSI ì „ëµ - ì„ ë¬¼ê±°ë˜ ìµœì í™”"""
    
    # ì „ëµ ë©”íƒ€ë°ì´í„°
    INTERFACE_VERSION = 3
    timeframe = '15m'
    can_short = True
    
    # ë¡œìŠ¤ ì¹´ë©”ë¡  ë§¤ê°œë³€ìˆ˜
    rsi_overbought = IntParameter(65, 80, default=70, space="sell")
    rsi_oversold = IntParameter(20, 35, default=30, space="buy")
    bb_deviation = DecimalParameter(1.8, 2.5, default=2.0, space="buy")
    
    def populate_indicators(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """ë¡œìŠ¤ ì¹´ë©”ë¡  ì§€í‘œ + ì„ ë¬¼ê±°ë˜ íŠ¹í™”"""
        
        # ë¶€ëª¨ í´ë˜ìŠ¤ ì§€í‘œ ìƒì†
        dataframe = super().populate_indicators(dataframe, metadata)
        
        # ë¡œìŠ¤ ì¹´ë©”ë¡  í•µì‹¬ ì§€í‘œ
        dataframe['rsi_14'] = ta.RSI(dataframe, timeperiod=14)
        dataframe['rsi_7'] = ta.RSI(dataframe, timeperiod=7)
        
        # ë‹¤ì¤‘ ì‹œê°„ëŒ€ RSI
        dataframe['rsi_slow'] = ta.RSI(dataframe, timeperiod=21)
        
        # ë³¼ë¦°ì €ë°´ë“œ (ë™ì  í¸ì°¨)
        bb = ta.BBANDS(dataframe, timeperiod=20, nbdevup=self.bb_deviation.value, 
                      nbdevdn=self.bb_deviation.value)
        dataframe['bb_upper'] = bb['upperband']
        dataframe['bb_middle'] = bb['middleband']
        dataframe['bb_lower'] = bb['lowerband']
        dataframe['bb_width'] = (dataframe['bb_upper'] - dataframe['bb_lower']) / dataframe['bb_middle']
        
        # ê°€ê²© ìœ„ì¹˜ (ë³¼ë¦°ì €ë°´ë“œ ë‚´)
        dataframe['bb_percent'] = (dataframe['close'] - dataframe['bb_lower']) / \
                                 (dataframe['bb_upper'] - dataframe['bb_lower'])
        
        # ì„ ë¬¼ê±°ë˜ íŠ¹í™” ì§€í‘œ
        dataframe['funding_rate'] = self.get_funding_rate_indicator(metadata['pair'])
        dataframe['long_short_ratio'] = self.get_long_short_ratio(metadata['pair'])
        
        # ê±°ë˜ëŸ‰ í™•ì¸
        dataframe['volume_sma'] = ta.SMA(dataframe['volume'], timeperiod=20)
        dataframe['volume_ratio'] = dataframe['volume'] / dataframe['volume_sma']
        
        return dataframe
    
    def populate_entry_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """ë¡œìŠ¤ ì¹´ë©”ë¡  ì§„ì… ì‹ í˜¸ (ì„ ë¬¼ ìµœì í™”)"""
        
        # ë¡± ì§„ì… - RSI ê³¼ë§¤ë„ + ë³¼ë°´ í•˜ë‹¨ + ìê¸ˆì¡°ë‹¬ë£Œ ê³ ë ¤
        long_conditions = [
            # í•µì‹¬ RSI ì¡°ê±´
            (dataframe['rsi_14'] < self.rsi_oversold.value),
            (dataframe['rsi_7'] < self.rsi_oversold.value + 5),
            
            # ë³¼ë¦°ì €ë°´ë“œ ì¡°ê±´
            (dataframe['close'] <= dataframe['bb_lower']),
            (dataframe['bb_percent'] < 0.2),  # í•˜ìœ„ 20% êµ¬ê°„
            
            # ê±°ë˜ëŸ‰ í™•ì¸
            (dataframe['volume_ratio'] > 1.2),  # í‰ê·  ëŒ€ë¹„ 20% ì´ìƒ
            
            # ì„ ë¬¼ê±°ë˜ íŠ¹í™” ì¡°ê±´
            (dataframe['funding_rate'] < 0),  # ìŒìˆ˜ ìê¸ˆì¡°ë‹¬ë£Œ (ë¡± ìœ ë¦¬)
            
            # ì¶”ê°€ í•„í„°
            (dataframe['bb_width'] > 0.02),  # ì¶©ë¶„í•œ ë³€ë™ì„±
        ]
        
        dataframe.loc[
            self.combine_conditions(long_conditions),
            'enter_long'
        ] = 1
        
        # ìˆ ì§„ì… - RSI ê³¼ë§¤ìˆ˜ + ë³¼ë°´ ìƒë‹¨ + ìê¸ˆì¡°ë‹¬ë£Œ ê³ ë ¤
        short_conditions = [
            # í•µì‹¬ RSI ì¡°ê±´
            (dataframe['rsi_14'] > self.rsi_overbought.value),
            (dataframe['rsi_7'] > self.rsi_overbought.value - 5),
            
            # ë³¼ë¦°ì €ë°´ë“œ ì¡°ê±´
            (dataframe['close'] >= dataframe['bb_upper']),
            (dataframe['bb_percent'] > 0.8),  # ìƒìœ„ 80% êµ¬ê°„
            
            # ê±°ë˜ëŸ‰ í™•ì¸
            (dataframe['volume_ratio'] > 1.2),
            
            # ì„ ë¬¼ê±°ë˜ íŠ¹í™” ì¡°ê±´
            (dataframe['funding_rate'] > 0.001),  # ì–‘ìˆ˜ ìê¸ˆì¡°ë‹¬ë£Œ (ìˆ ìœ ë¦¬)
            
            # ì¶”ê°€ í•„í„°
            (dataframe['bb_width'] > 0.02),
        ]
        
        dataframe.loc[
            self.combine_conditions(short_conditions),
            'enter_short'
        ] = 1
        
        return dataframe
    
    def populate_exit_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """ë¡œìŠ¤ ì¹´ë©”ë¡  ì²­ì‚° ì‹ í˜¸"""
        
        # ë¡± ì²­ì‚° - RSI íšŒë³µ ë˜ëŠ” ë³¼ë°´ ì¤‘ê°„ì„  ë„ë‹¬
        dataframe.loc[
            (
                (dataframe['rsi_14'] > 50) |
                (dataframe['close'] > dataframe['bb_middle']) |
                (dataframe['bb_percent'] > 0.6)
            ),
            'exit_long'
        ] = 1
        
        # ìˆ ì²­ì‚° - RSI í•˜ë½ ë˜ëŠ” ë³¼ë°´ ì¤‘ê°„ì„  ë„ë‹¬
        dataframe.loc[
            (
                (dataframe['rsi_14'] < 50) |
                (dataframe['close'] < dataframe['bb_middle']) |
                (dataframe['bb_percent'] < 0.4)
            ),
            'exit_short'
        ] = 1
        
        return dataframe
    
    def combine_conditions(self, conditions: list) -> pd.Series:
        """ì¡°ê±´ë“¤ì„ ANDë¡œ ê²°í•©"""
        result = conditions[0]
        for condition in conditions[1:]:
            result = result & condition
        return result
```

#### 4.2 ì„ ë¬¼ê±°ë˜ íŠ¹í™” í—¬í¼ ë©”ì„œë“œ
```python
def get_funding_rate_indicator(self, pair: str) -> pd.Series:
    """ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ ì§€í‘œ ìƒì„±"""
    try:
        # ì‹¤ì œ APIì—ì„œ ìê¸ˆì¡°ë‹¬ë£Œ ê°€ì ¸ì˜¤ê¸°
        funding_rate = self.exchange.fetch_funding_rate(pair)
        current_rate = funding_rate['fundingRate']
        
        # ì‹œë¦¬ì¦ˆë¡œ ë³€í™˜ (ì„ì‹œ êµ¬í˜„)
        return pd.Series([current_rate] * 1000)  # ì‹¤ì œë¡œëŠ” historical ë°ì´í„° í•„ìš”
        
    except Exception:
        # ê¸°ë³¸ê°’ ë°˜í™˜
        return pd.Series([0.0] * 1000)

def get_long_short_ratio(self, pair: str) -> pd.Series:
    """ë¡±/ìˆ ë¹„ìœ¨ ì§€í‘œ"""
    try:
        # Binance Futures APIì—ì„œ ë¡±/ìˆ ë¹„ìœ¨ ê°€ì ¸ì˜¤ê¸°
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” historical ë°ì´í„° í•„ìš”
        return pd.Series([1.0] * 1000)  # ì¤‘ë¦½ ë¹„ìœ¨
        
    except Exception:
        return pd.Series([1.0] * 1000)

def custom_entry_price(self, pair: str, current_time, proposed_rate: float, 
                      entry_tag: str, side: str, **kwargs) -> float:
    """ë¡œìŠ¤ ì¹´ë©”ë¡  ìŠ¤íƒ€ì¼ ì§„ì…ê°€ ìµœì í™”"""
    
    dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
    
    if side == "long":
        # ë³¼ë¦°ì €ë°´ë“œ í•˜ë‹¨ ê·¼ì²˜ì—ì„œ ì§„ì…
        bb_lower = dataframe['bb_lower'].iloc[-1]
        return min(proposed_rate, bb_lower * 1.001)  # 0.1% ìœ„
        
    elif side == "short":
        # ë³¼ë¦°ì €ë°´ë“œ ìƒë‹¨ ê·¼ì²˜ì—ì„œ ì§„ì…
        bb_upper = dataframe['bb_upper'].iloc[-1]
        return max(proposed_rate, bb_upper * 0.999)  # 0.1% ì•„ë˜
    
    return proposed_rate

def custom_exit_price(self, pair: str, trade, current_time, proposed_rate: float, 
                     current_profit: float, **kwargs) -> float:
    """ìˆ˜ìµ ìµœì í™” ì²­ì‚°ê°€ ê³„ì‚°"""
    
    dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
    bb_middle = dataframe['bb_middle'].iloc[-1]
    
    # ë³¼ë¦°ì €ë°´ë“œ ì¤‘ê°„ì„ ì—ì„œ ì²­ì‚° ëª©í‘œ
    if trade.is_short:
        return min(proposed_rate, bb_middle)
    else:
        return max(proposed_rate, bb_middle)
```

### âœ… Phase 4 ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ë¡œìŠ¤ ì¹´ë©”ë¡  RSI ì „ëµ í´ë˜ìŠ¤ ì™„ì„±
- [ ] ë¡±/ìˆ ì–‘ë°©í–¥ ì§„ì… ì¡°ê±´ êµ¬í˜„
- [ ] ë³¼ë¦°ì €ë°´ë“œ + RSI ì¡°í•© ë¡œì§ ì™„ì„±
- [ ] ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ ê³ ë ¤ ì¡°ê±´ ì¶”ê°€
- [ ] ê±°ë˜ëŸ‰ í•„í„°ë§ êµ¬í˜„
- [ ] ë°±í…ŒìŠ¤íŒ…ìœ¼ë¡œ ì „ëµ ì„±ëŠ¥ ê²€ì¦

### ğŸ§ª Phase 4 í…ŒìŠ¤íŠ¸
```bash
# ë¡œìŠ¤ ì¹´ë©”ë¡  ì „ëµ ë°±í…ŒìŠ¤íŒ…
freqtrade backtesting \
  --config user_data/config_futures.json \
  --strategy RossCameronFuturesStrategy \
  --timerange 20241001-20241201 \
  --breakdown day week
```

---

## ğŸ”§ Phase 5: ê³ ê¸‰ ì„ ë¬¼ ê±°ë˜ ê¸°ëŠ¥

### ğŸ¯ ëª©í‘œ
- ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ ìˆ˜ìµ ì°½ì¶œ ì‹œìŠ¤í…œ
- í¬ì§€ì…˜ ëª¨ë“œ ê´€ë¦¬ (One-way/Hedge)
- ADL ë° ê°•ì œ ì²­ì‚° ë°©ì§€ ì‹œìŠ¤í…œ

### ğŸ“‹ êµ¬í˜„ ë‹¨ê³„

#### 5.1 ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ í™œìš© ì‹œìŠ¤í…œ
```python
# user_data/strategies/modules/funding_rate_manager.py
import requests
import time
from datetime import datetime, timedelta

class FundingRateManager:
    """ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self, exchange):
        self.exchange = exchange
        self.funding_threshold = 0.01  # 1% ì´ìƒ ìˆ˜ìˆ˜ë£Œ
        
    def get_current_funding_rate(self, pair: str) -> float:
        """í˜„ì¬ ìê¸ˆ ì¡°ë‹¬ ìˆ˜ìˆ˜ë£Œ ì¡°íšŒ"""
        try:
            funding_info = self.exchange.fetch_funding_rate(pair)
            return funding_info['fundingRate']
        except Exception as e:
            print(f"Funding rate fetch error: {e}")
            return 0.0
    
    def get_next_funding_time(self, pair: str) -> datetime:
        """ë‹¤ìŒ ìê¸ˆ ì¡°ë‹¬ ì‹œê°„ ê³„ì‚°"""
        try:
            funding_info = self.exchange.fetch_funding_rate(pair)
            return datetime.fromtimestamp(funding_info['fundingTimestamp'] / 1000)
        except Exception:
            # ê¸°ë³¸ê°’: 8ì‹œê°„ë§ˆë‹¤ (Binance ê¸°ì¤€)
            now = datetime.now()
            next_funding = now.replace(minute=0, second=0, microsecond=0)
            while next_funding.hour not in [0, 8, 16]:
                next_funding += timedelta(hours=1)
            if next_funding <= now:
                next_funding += timedelta(hours=8)
            return next_funding
    
    def analyze_funding_opportunity(self, pair: str) -> dict:
        """ìê¸ˆ ì¡°ë‹¬ë£Œ ìˆ˜ìµ ê¸°íšŒ ë¶„ì„"""
        
        current_rate = self.get_current_funding_rate(pair)
        next_time = self.get_next_funding_time(pair)
        time_to_funding = (next_time - datetime.now()).total_seconds() / 3600
        
        analysis = {
            'pair': pair,
            'funding_rate': current_rate,
            'next_funding_time': next_time,
            'hours_to_funding': time_to_funding,
            'recommendation': 'neutral'
        }
        
        # ë†’ì€ ì–‘ì˜ ìˆ˜ìˆ˜ë£Œ = ìˆ í¬ì§€ì…˜ ìœ ë¦¬
        if current_rate > self.funding_threshold:
            analysis['recommendation'] = 'short_favorable'
            analysis['expected_income'] = current_rate  # 8ì‹œê°„ë‹¹ ìˆ˜ìµë¥ 
            
        # ë†’ì€ ìŒì˜ ìˆ˜ìˆ˜ë£Œ = ë¡± í¬ì§€ì…˜ ìœ ë¦¬
        elif current_rate < -self.funding_threshold:
            analysis['recommendation'] = 'long_favorable' 
            analysis['expected_income'] = abs(current_rate)
            
        return analysis
    
    def should_hold_for_funding(self, pair: str, side: str) -> bool:
        """ìê¸ˆ ì¡°ë‹¬ë£Œ ìˆ˜ìµì„ ìœ„í•´ í¬ì§€ì…˜ ìœ ì§€ ì—¬ë¶€ íŒë‹¨"""
        
        analysis = self.analyze_funding_opportunity(pair)
        
        # ìˆ˜ìµì„± ìˆëŠ” ìê¸ˆ ì¡°ë‹¬ë£Œì´ê³  ì‹œê°„ì´ 2ì‹œê°„ ì´ë‚´
        if (analysis['hours_to_funding'] < 2 and 
            abs(analysis['funding_rate']) > 0.005):  # 0.5% ì´ìƒ
            
            if side == 'long' and analysis['recommendation'] == 'long_favorable':
                return True
            elif side == 'short' and analysis['recommendation'] == 'short_favorable':
                return True
                
        return False
```

#### 5.2 í¬ì§€ì…˜ ëª¨ë“œ ê´€ë¦¬
```python
# user_data/strategies/modules/position_manager.py
class PositionManager:
    """í¬ì§€ì…˜ ëª¨ë“œ ë° ë§ˆì§„ ê´€ë¦¬"""
    
    def __init__(self, exchange):
        self.exchange = exchange
        
    def set_position_mode(self, hedge_mode: bool = False):
        """í¬ì§€ì…˜ ëª¨ë“œ ì„¤ì • (One-way/Hedge)"""
        try:
            # Binance Futures API
            if hedge_mode:
                self.exchange._api.futures_change_position_mode(dualSidePosition=True)
                print("âœ… Hedge mode activated (Long/Short ë™ì‹œ ê°€ëŠ¥)")
            else:
                self.exchange._api.futures_change_position_mode(dualSidePosition=False)
                print("âœ… One-way mode activated (ê¸°ë³¸ ëª¨ë“œ)")
                
        except Exception as e:
            print(f"Position mode change error: {e}")
    
    def set_margin_mode(self, pair: str, margin_type: str = "ISOLATED"):
        """ë§ˆì§„ ëª¨ë“œ ì„¤ì •"""
        try:
            symbol = pair.replace('/', '')
            self.exchange._api.futures_change_margin_type(
                symbol=symbol, 
                marginType=margin_type
            )
            print(f"âœ… {pair} margin mode set to {margin_type}")
            
        except Exception as e:
            if "No need to change margin type" in str(e):
                print(f"â„¹ï¸  {pair} already in {margin_type} mode")
            else:
                print(f"Margin mode change error: {e}")
    
    def adjust_leverage(self, pair: str, leverage: int):
        """ë ˆë²„ë¦¬ì§€ ì¡°ì •"""
        try:
            symbol = pair.replace('/', '')
            result = self.exchange._api.futures_change_leverage(
                symbol=symbol,
                leverage=leverage
            )
            print(f"âœ… {pair} leverage set to {leverage}x")
            return result
            
        except Exception as e:
            print(f"Leverage adjustment error: {e}")
            return None
    
    def get_position_risk(self, pair: str = None) -> dict:
        """í¬ì§€ì…˜ ë¦¬ìŠ¤í¬ ì •ë³´ ì¡°íšŒ"""
        try:
            positions = self.exchange._api.futures_position_information()
            
            if pair:
                symbol = pair.replace('/', '')
                for pos in positions:
                    if pos['symbol'] == symbol:
                        return self._format_position_risk(pos)
            else:
                # ëª¨ë“  í™œì„± í¬ì§€ì…˜ ë¦¬ìŠ¤í¬
                active_positions = []
                for pos in positions:
                    if float(pos['positionAmt']) != 0:
                        active_positions.append(self._format_position_risk(pos))
                return active_positions
                
        except Exception as e:
            print(f"Position risk fetch error: {e}")
            return {}
    
    def _format_position_risk(self, position: dict) -> dict:
        """í¬ì§€ì…˜ ë¦¬ìŠ¤í¬ ì •ë³´ í¬ë§·íŒ…"""
        
        position_amt = float(position['positionAmt'])
        mark_price = float(position['markPrice'])
        liquidation_price = float(position['liquidationPrice'])
        margin_ratio = float(position['marginRatio'])
        
        return {
            'symbol': position['symbol'],
            'side': 'LONG' if position_amt > 0 else 'SHORT',
            'size': abs(position_amt),
            'entry_price': float(position['entryPrice']),
            'mark_price': mark_price,
            'liquidation_price': liquidation_price,
            'unrealized_pnl': float(position['unRealizedProfit']),
            'margin_ratio': margin_ratio,
            'liquidation_distance': abs(mark_price - liquidation_price) / mark_price if liquidation_price > 0 else 1.0,
            'leverage': int(1 / margin_ratio) if margin_ratio > 0 else 1
        }
```

#### 5.3 ë¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ
```python
# user_data/strategies/modules/risk_monitor.py
import time
import threading
from datetime import datetime

class RiskMonitor:
    """ì‹¤ì‹œê°„ ë¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, position_manager, telegram_bot=None):
        self.position_manager = position_manager
        self.telegram_bot = telegram_bot
        self.monitoring = False
        
        # ìœ„í—˜ ì„ê³„ê°’
        self.liquidation_warning_threshold = 0.15  # 15% ì´ë‚´
        self.margin_ratio_warning = 0.8  # 80% ì´ìƒ
        
    def start_monitoring(self, interval: int = 30):
        """ë¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.monitoring = True
        thread = threading.Thread(target=self._monitor_loop, args=(interval,))
        thread.daemon = True
        thread.start()
        print("ğŸ” Risk monitoring started")
    
    def stop_monitoring(self):
        """ë¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.monitoring = False
        print("â¹ï¸  Risk monitoring stopped")
    
    def _monitor_loop(self, interval: int):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while self.monitoring:
            try:
                self._check_all_positions()
                time.sleep(interval)
            except Exception as e:
                print(f"Monitoring error: {e}")
                time.sleep(60)  # ì—ëŸ¬ ì‹œ 1ë¶„ ëŒ€ê¸°
    
    def _check_all_positions(self):
        """ëª¨ë“  í¬ì§€ì…˜ ìœ„í—˜ë„ í™•ì¸"""
        positions = self.position_manager.get_position_risk()
        
        if isinstance(positions, list):
            for position in positions:
                self._check_position_risk(position)
    
    def _check_position_risk(self, position: dict):
        """ê°œë³„ í¬ì§€ì…˜ ìœ„í—˜ë„ í™•ì¸"""
        symbol = position['symbol']
        liquidation_distance = position['liquidation_distance']
        margin_ratio = position['margin_ratio']
        
        # ê°•ì œ ì²­ì‚° ê²½ê³ 
        if liquidation_distance < self.liquidation_warning_threshold:
            warning_msg = (
                f"ğŸš¨ LIQUIDATION WARNING\n"
                f"Symbol: {symbol}\n"
                f"Distance to liquidation: {liquidation_distance:.2%}\n"
                f"Current margin ratio: {margin_ratio:.2%}\n"
                f"Action: Consider reducing position or adding margin"
            )
            self._send_alert(warning_msg)
        
        # ë§ˆì§„ ë¹„ìœ¨ ê²½ê³ 
        elif margin_ratio > self.margin_ratio_warning:
            warning_msg = (
                f"âš ï¸ HIGH MARGIN USAGE\n"
                f"Symbol: {symbol}\n"
                f"Margin ratio: {margin_ratio:.2%}\n"
                f"Recommendation: Monitor closely"
            )
            self._send_alert(warning_msg)
    
    def _send_alert(self, message: str):
        """ì•Œë¦¼ ë°œì†¡"""
        print(f"ALERT: {message}")
        
        if self.telegram_bot:
            try:
                self.telegram_bot.send_message(message)
            except Exception as e:
                print(f"Telegram alert failed: {e}")
```

### âœ… Phase 5 ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] FundingRateManager í´ë˜ìŠ¤ êµ¬í˜„
- [ ] ìê¸ˆ ì¡°ë‹¬ë£Œ ë¶„ì„ ë¡œì§ ì™„ì„±
- [ ] PositionManagerë¡œ í¬ì§€ì…˜ ëª¨ë“œ ê´€ë¦¬
- [ ] ë ˆë²„ë¦¬ì§€ ë™ì  ì¡°ì • ê¸°ëŠ¥
- [ ] RiskMonitorë¡œ ì‹¤ì‹œê°„ ìœ„í—˜ ê°ì§€
- [ ] ê°•ì œ ì²­ì‚° ê²½ê³  ì‹œìŠ¤í…œ êµ¬í˜„

---

## ğŸ“Š Phase 6: ë°±í…ŒìŠ¤íŒ… ë° ìµœì í™”

### ğŸ¯ ëª©í‘œ
- ì„ ë¬¼ê±°ë˜ ë°ì´í„° ë‹¤ìš´ë¡œë“œ ë° ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰
- í•˜ì´í¼íŒŒë¼ë¯¸í„° ìµœì í™”
- ì „ëµ ì„±ëŠ¥ ë¶„ì„ ë° ë¦¬í¬íŠ¸ ìƒì„±

### ğŸ“‹ êµ¬í˜„ ë‹¨ê³„

#### 6.1 ì„ ë¬¼ê±°ë˜ ë°ì´í„° ë‹¤ìš´ë¡œë“œ
```bash
# ìŠ¤í¬ë¦½íŠ¸ ìƒì„±: scripts/download_futures_data.sh
#!/bin/bash

echo "ğŸ”„ Downloading Binance Futures data..."

# ì£¼ìš” USDT Perpetual í˜ì–´
PAIRS="BTCUSDT ETHUSDT ADAUSDT SOLUSDT BNBUSDT AVAXUSDT MATICUSDT DOTUSDT LINKUSDT LTCUSDT"

# ë‹¤ì¤‘ ì‹œê°„ëŒ€ ë°ì´í„°
TIMEFRAMES="15m 1h 4h 1d"

# 90ì¼ ë°ì´í„° ë‹¤ìš´ë¡œë“œ
freqtrade download-data \
  --exchange binance \
  --trading-mode futures \
  --timeframes $TIMEFRAMES \
  --pairs $PAIRS \
  --days 90 \
  --config user_data/config_futures.json \
  --data-format-ohlcv json

echo "âœ… Data download completed"

# ë°ì´í„° í™•ì¸
freqtrade list-data \
  --config user_data/config_futures.json \
  --trading-mode futures
```

#### 6.2 ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
```python
# scripts/run_backtests.py
import subprocess
import json
import os
from datetime import datetime, timedelta

class FuturesBacktester:
    """ì„ ë¬¼ê±°ë˜ ë°±í…ŒìŠ¤íŒ… ìë™í™”"""
    
    def __init__(self):
        self.config_path = "user_data/config_futures.json"
        self.results_dir = "user_data/backtest_results"
        os.makedirs(self.results_dir, exist_ok=True)
    
    def run_strategy_backtest(self, strategy_name: str, timerange: str = None):
        """ê°œë³„ ì „ëµ ë°±í…ŒìŠ¤íŒ…"""
        
        if not timerange:
            # ê¸°ë³¸: ìµœê·¼ 60ì¼
            end_date = datetime.now()
            start_date = end_date - timedelta(days=60)
            timerange = f"{start_date.strftime('%Y%m%d')}-{end_date.strftime('%Y%m%d')}"
        
        cmd = [
            "freqtrade", "backtesting",
            "--config", self.config_path,
            "--strategy", strategy_name,
            "--trading-mode", "futures",
            "--timerange", timerange,
            "--breakdown", "day",
            "--export", "trades",
            "--export-filename", f"{self.results_dir}/{strategy_name}_{timerange}.json"
        ]
        
        print(f"ğŸ”„ Running backtest for {strategy_name}...")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)
            
            if result.returncode == 0:
                print(f"âœ… {strategy_name} backtest completed")
                self._parse_backtest_results(strategy_name, result.stdout)
                return True
            else:
                print(f"âŒ {strategy_name} backtest failed:")
                print(result.stderr)
                return False
                
        except subprocess.TimeoutExpired:
            print(f"â±ï¸  {strategy_name} backtest timed out")
            return False
    
    def run_all_strategies(self):
        """ëª¨ë“  ì „ëµ ë°±í…ŒìŠ¤íŒ…"""
        strategies = [
            "FuturesAIRiskStrategy",
            "RossCameronFuturesStrategy"
        ]
        
        results = {}
        for strategy in strategies:
            results[strategy] = self.run_strategy_backtest(strategy)
        
        return results
    
    def _parse_backtest_results(self, strategy_name: str, output: str):
        """ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ íŒŒì‹±"""
        lines = output.split('\n')
        results = {}
        
        # í•µì‹¬ ì§€í‘œ ì¶”ì¶œ
        for line in lines:
            if "Total Profit" in line:
                results['total_profit'] = line.split(':')[-1].strip()
            elif "Total trade count" in line:
                results['total_trades'] = line.split(':')[-1].strip()
            elif "Win %" in line:
                results['win_rate'] = line.split(':')[-1].strip()
            elif "Max Drawdown" in line:
                results['max_drawdown'] = line.split(':')[-1].strip()
            elif "Sharpe Ratio" in line:
                results['sharpe_ratio'] = line.split(':')[-1].strip()
        
        # ê²°ê³¼ ì €ì¥
        result_file = f"{self.results_dir}/{strategy_name}_summary.json"
        with open(result_file, 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"ğŸ“Š {strategy_name} Results:")
        for key, value in results.items():
            print(f"  {key}: {value}")

if __name__ == "__main__":
    backtester = FuturesBacktester()
    backtester.run_all_strategies()
```

#### 6.3 í•˜ì´í¼íŒŒë¼ë¯¸í„° ìµœì í™”
```bash
# scripts/run_hyperopt.sh
#!/bin/bash

echo "ğŸ”§ Starting hyperparameter optimization..."

STRATEGY="RossCameronFuturesStrategy"
TIMERANGE="20241001-20241201"

# ì„ ë¬¼ê±°ë˜ íŠ¹í™” í•˜ì´í¼ì˜µíŠ¸
freqtrade hyperopt \
  --config user_data/config_futures.json \
  --strategy $STRATEGY \
  --hyperopt-loss SortinoHyperOptLoss \
  --spaces buy sell roi stoploss \
  --epochs 200 \
  --trading-mode futures \
  --timerange $TIMERANGE \
  --min-trades 50 \
  --print-all

echo "âœ… Hyperopt completed"

# ìµœì  íŒŒë¼ë¯¸í„° ì ìš©
freqtrade hyperopt-show \
  --config user_data/config_futures.json \
  --strategy $STRATEGY \
  --print-json > user_data/hyperopt_results/${STRATEGY}_best_params.json
```

#### 6.4 ì„±ê³¼ ë¶„ì„ ë„êµ¬
```python
# scripts/analyze_performance.py
import json
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

class PerformanceAnalyzer:
    """ë°±í…ŒìŠ¤íŒ… ì„±ê³¼ ë¶„ì„"""
    
    def __init__(self, results_dir: str = "user_data/backtest_results"):
        self.results_dir = Path(results_dir)
        
    def load_trade_data(self, strategy_name: str) -> pd.DataFrame:
        """ê±°ë˜ ë°ì´í„° ë¡œë“œ"""
        
        # ê°€ì¥ ìµœê·¼ ê±°ë˜ íŒŒì¼ ì°¾ê¸°
        trade_files = list(self.results_dir.glob(f"{strategy_name}_*-trades.json"))
        if not trade_files:
            print(f"No trade data found for {strategy_name}")
            return pd.DataFrame()
        
        latest_file = sorted(trade_files)[-1]
        
        with open(latest_file, 'r') as f:
            data = json.load(f)
        
        return pd.DataFrame(data)
    
    def analyze_futures_performance(self, strategy_name: str) -> dict:
        """ì„ ë¬¼ê±°ë˜ ì„±ê³¼ ìƒì„¸ ë¶„ì„"""
        
        trades_df = self.load_trade_data(strategy_name)
        
        if trades_df.empty:
            return {}
        
        # ê¸°ë³¸ í†µê³„
        total_trades = len(trades_df)
        long_trades = len(trades_df[trades_df['is_short'] == False])
        short_trades = len(trades_df[trades_df['is_short'] == True])
        
        # ìˆ˜ìµì„± ë¶„ì„
        profitable_trades = len(trades_df[trades_df['profit_abs'] > 0])
        win_rate = profitable_trades / total_trades if total_trades > 0 else 0
        
        # ë ˆë²„ë¦¬ì§€ ë¶„ì„
        avg_leverage = trades_df['leverage'].mean() if 'leverage' in trades_df.columns else 1
        max_leverage = trades_df['leverage'].max() if 'leverage' in trades_df.columns else 1
        
        # ìˆ˜ìµ ë¶„ì„
        total_profit = trades_df['profit_abs'].sum()
        avg_profit_per_trade = trades_df['profit_abs'].mean()
        best_trade = trades_df['profit_abs'].max()
        worst_trade = trades_df['profit_abs'].min()
        
        # ê¸°ê°„ ë¶„ì„
        trades_df['open_date'] = pd.to_datetime(trades_df['open_date'])
        trades_df['close_date'] = pd.to_datetime(trades_df['close_date'])
        trades_df['duration_hours'] = (trades_df['close_date'] - trades_df['open_date']).dt.total_seconds() / 3600
        avg_duration = trades_df['duration_hours'].mean()
        
        # ìê¸ˆ ì¡°ë‹¬ë£Œ ë¶„ì„ (ì¶”ì •)
        funding_fees = 0
        if 'funding_fees' in trades_df.columns:
            funding_fees = trades_df['funding_fees'].sum()
        
        return {
            'strategy': strategy_name,
            'total_trades': total_trades,
            'long_trades': long_trades,
            'short_trades': short_trades,
            'win_rate': win_rate,
            'total_profit': total_profit,
            'avg_profit_per_trade': avg_profit_per_trade,
            'best_trade': best_trade,
            'worst_trade': worst_trade,
            'avg_leverage': avg_leverage,
            'max_leverage': max_leverage,
            'avg_duration_hours': avg_duration,
            'funding_fees': funding_fees,
            'net_profit': total_profit - abs(funding_fees)
        }
    
    def create_performance_report(self, strategy_name: str):
        """ì„±ê³¼ ë¦¬í¬íŠ¸ ìƒì„±"""
        
        analysis = self.analyze_futures_performance(strategy_name)
        
        if not analysis:
            print("No data to analyze")
            return
        
        # í…ìŠ¤íŠ¸ ë¦¬í¬íŠ¸
        report = f"""
ğŸš€ {strategy_name} Performance Report
{'='*50}

ğŸ“Š Trade Statistics:
  Total Trades: {analysis['total_trades']}
  Long Trades: {analysis['long_trades']} ({analysis['long_trades']/analysis['total_trades']:.1%})
  Short Trades: {analysis['short_trades']} ({analysis['short_trades']/analysis['total_trades']:.1%})
  Win Rate: {analysis['win_rate']:.2%}

ğŸ’° Profitability:
  Total Profit: ${analysis['total_profit']:.2f}
  Avg Profit/Trade: ${analysis['avg_profit_per_trade']:.2f}
  Best Trade: ${analysis['best_trade']:.2f}
  Worst Trade: ${analysis['worst_trade']:.2f}

âš–ï¸ Leverage Analysis:
  Average Leverage: {analysis['avg_leverage']:.1f}x
  Maximum Leverage: {analysis['max_leverage']:.1f}x

â±ï¸ Duration:
  Average Trade Duration: {analysis['avg_duration_hours']:.1f} hours

ğŸ’¸ Futures Specific:
  Estimated Funding Fees: ${analysis['funding_fees']:.2f}
  Net Profit (after fees): ${analysis['net_profit']:.2f}
        """
        
        print(report)
        
        # ë¦¬í¬íŠ¸ íŒŒì¼ ì €ì¥
        report_file = self.results_dir / f"{strategy_name}_report.txt"
        with open(report_file, 'w') as f:
            f.write(report)
        
        print(f"ğŸ“„ Report saved to {report_file}")

if __name__ == "__main__":
    analyzer = PerformanceAnalyzer()
    
    strategies = ["FuturesAIRiskStrategy", "RossCameronFuturesStrategy"]
    for strategy in strategies:
        analyzer.create_performance_report(strategy)
```

### âœ… Phase 6 ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ì„ ë¬¼ê±°ë˜ ë°ì´í„° ë‹¤ìš´ë¡œë“œ ì™„ë£Œ
- [ ] ì „ëµë³„ ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ ì„±ê³µ
- [ ] í•˜ì´í¼íŒŒë¼ë¯¸í„° ìµœì í™” ìˆ˜í–‰
- [ ] ì„±ê³¼ ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±
- [ ] ë ˆë²„ë¦¬ì§€ë³„ ìˆ˜ìµë¥  ë¶„ì„
- [ ] ìê¸ˆ ì¡°ë‹¬ë£Œ ì˜í–¥ ë¶„ì„

---

## ğŸ¯ ë‹¤ìŒ Phase ë¯¸ë¦¬ë³´ê¸°

### Phase 7-10 ìš”ì•½

| Phase | í•µì‹¬ ë‚´ìš© | ì˜ˆìƒ ì‹œê°„ |
|-------|-----------|----------|
| **Phase 7** | FreqUI ì›¹ ì¸í„°í˜ì´ìŠ¤ + ì„ ë¬¼ íŠ¹í™” ëŒ€ì‹œë³´ë“œ | 3ì‹œê°„ |
| **Phase 8** | í…”ë ˆê·¸ë¨ ë´‡ + ì„ ë¬¼ê±°ë˜ ì „ìš© ì•Œë¦¼ | 2ì‹œê°„ |
| **Phase 9** | Vultr ì„œë²„ ë°°í¬ + ì„œìš¸ ë¦¬ì „ ìµœì í™” | 4ì‹œê°„ |
| **Phase 10** | ê³ ê¸‰ ëª¨ë‹ˆí„°ë§ + ìë™ ë°±ì—… ì‹œìŠ¤í…œ | 6ì‹œê°„ |

---

## âœ… ì—ì´ì „í‹± ì½”ë”© ì›ì¹™ ì¤€ìˆ˜

### ğŸ”„ ë§¤ Phase í›„ ì²´í¬ì‚¬í•­

1. **âœ… ê¸°ëŠ¥ ê²€ì¦**: êµ¬í˜„í•œ ê¸°ëŠ¥ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
2. **ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹¤í–‰**: ë°±í…ŒìŠ¤íŒ…/ìœ ë‹›í…ŒìŠ¤íŠ¸ í†µê³¼í•˜ëŠ”ê°€?
3. **ğŸ“ ë¬¸ì„œ ì—…ë°ì´íŠ¸**: ë³€ê²½ì‚¬í•­ì´ ë¬¸ì„œí™”ë˜ì—ˆëŠ”ê°€?
4. **ğŸš€ ì ì§„ì  ë°°í¬**: í…ŒìŠ¤íŠ¸ë„·ì—ì„œ ê²€ì¦ ì™„ë£Œí–ˆëŠ”ê°€?
5. **ğŸ”„ ë‹¤ìŒ Phase ì¤€ë¹„**: ì˜ì¡´ì„±ê³¼ ìš”êµ¬ì‚¬í•­ í™•ì¸í–ˆëŠ”ê°€?

### ğŸ¯ ì„±ê³µ ê¸°ì¤€

- **ê° Phaseë³„ 95% ì´ìƒ ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ**
- **í…ŒìŠ¤íŠ¸ë„·ì—ì„œ 24ì‹œê°„ ì´ìƒ ì•ˆì •ì  ì‘ë™**
- **ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ ì–‘ìˆ˜ ìˆ˜ìµë¥  ë‹¬ì„±**
- **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì •ìƒ ì‘ë™**

---

<div align="center">

**ğŸ› ï¸ ì§€ê¸ˆ Phase 1ë¶€í„° ì‹œì‘í•˜ì—¬ ì²´ê³„ì ìœ¼ë¡œ êµ¬í˜„í•´ë³´ì„¸ìš”! ğŸ› ï¸**

[![Start Phase 1](https://img.shields.io/badge/Start%20Phase%201-ğŸš€%20í™˜ê²½%20ì„¤ì •-success?style=for-the-badge&logo=python)](../scripts/phase1_setup.sh)

</div>
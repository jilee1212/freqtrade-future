#!/usr/bin/env python3
"""
Risk Monitor
===========

Ïã§ÏãúÍ∞Ñ Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ Î∞è Í∞ïÏ†ú Ï≤≠ÏÇ∞ Î∞©ÏßÄ ÏãúÏä§ÌÖú
- ÎßàÏßÑ ÎπÑÏú® Ïã§ÏãúÍ∞Ñ Í∞êÏãú
- Ï≤≠ÏÇ∞Í∞Ä Ï†ëÍ∑º ÏïåÎ¶º
- ÏûêÎèô Î¶¨Ïä§ÌÅ¨ ÏôÑÌôî Ï°∞Ïπò
- ADL(Auto-Deleveraging) Î∞©ÏßÄ
"""

import time
import threading
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Callable
import logging
from dataclasses import dataclass, asdict
from enum import Enum

logger = logging.getLogger(__name__)

class AlertLevel(Enum):
    """ÏïåÎ¶º Î†àÎ≤®"""
    INFO = "INFO"
    WARNING = "WARNING"
    CRITICAL = "CRITICAL"
    EMERGENCY = "EMERGENCY"

class RiskMetric(Enum):
    """Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú"""
    MARGIN_RATIO = "margin_ratio"
    LIQUIDATION_DISTANCE = "liquidation_distance"
    UNREALIZED_PNL = "unrealized_pnl"
    PORTFOLIO_VAR = "portfolio_var"
    ADL_RISK = "adl_risk"

@dataclass
class RiskAlert:
    """Î¶¨Ïä§ÌÅ¨ ÏïåÎ¶º"""
    timestamp: datetime
    alert_level: AlertLevel
    metric: RiskMetric
    symbol: str
    current_value: float
    threshold: float
    message: str
    suggested_action: str
    priority: int  # 1-10 (10Ïù¥ ÏµúÍ≥† Ïö∞ÏÑ†ÏàúÏúÑ)

class RiskMonitor:
    """Ïã§ÏãúÍ∞Ñ Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ"""

    def __init__(self, position_manager, funding_manager=None, telegram_bot=None):
        self.position_manager = position_manager
        self.funding_manager = funding_manager
        self.telegram_bot = telegram_bot

        self.monitoring = False
        self.alert_history = []
        self.notification_handlers = []

        # Î¶¨Ïä§ÌÅ¨ ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï
        self.thresholds = {
            'margin_ratio': {
                'warning': 0.6,     # 60% ÎßàÏßÑ ÏÇ¨Ïö©
                'critical': 0.8,    # 80% ÎßàÏßÑ ÏÇ¨Ïö©
                'emergency': 0.9    # 90% ÎßàÏßÑ ÏÇ¨Ïö©
            },
            'liquidation_distance': {
                'warning': 0.2,     # 20% Í±∞Î¶¨
                'critical': 0.1,    # 10% Í±∞Î¶¨
                'emergency': 0.05   # 5% Í±∞Î¶¨
            },
            'unrealized_pnl': {
                'warning': -0.1,    # -10% ÏÜêÏã§
                'critical': -0.2,   # -20% ÏÜêÏã§
                'emergency': -0.3   # -30% ÏÜêÏã§
            }
        }

        # ÏûêÎèô ÎåÄÏùë ÏÑ§Ï†ï
        self.auto_actions = {
            'reduce_position_on_critical': True,
            'close_position_on_emergency': True,
            'send_telegram_alerts': True,
            'log_all_alerts': True
        }

    def start_monitoring(self, interval: int = 30) -> bool:
        """Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë"""
        try:
            if self.monitoring:
                logger.warning("Risk monitoring is already running")
                return False

            self.monitoring = True

            # Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú ÏãúÏûë
            monitor_thread = threading.Thread(
                target=self._monitor_loop,
                args=(interval,),
                daemon=True
            )
            monitor_thread.start()

            logger.info(f"üîç Risk monitoring started (interval: {interval}s)")
            return True

        except Exception as e:
            logger.error(f"Failed to start risk monitoring: {e}")
            return False

    def stop_monitoring(self):
        """Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ"""
        self.monitoring = False
        logger.info("‚èπÔ∏è  Risk monitoring stopped")

    def _monitor_loop(self, interval: int):
        """Î™®ÎãàÌÑ∞ÎßÅ Î©îÏù∏ Î£®ÌîÑ"""
        while self.monitoring:
            try:
                self._check_all_risks()
                time.sleep(interval)
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                time.sleep(60)  # ÏóêÎü¨ Ïãú 1Î∂Ñ ÎåÄÍ∏∞

    def _check_all_risks(self):
        """Î™®Îì† Î¶¨Ïä§ÌÅ¨ ÌôïÏù∏"""

        # ÌôúÏÑ± Ìè¨ÏßÄÏÖò Ï°∞Ìöå
        positions = self.position_manager.get_position_info()
        if not positions:
            return

        # Í∞Å Ìè¨ÏßÄÏÖòÎ≥Ñ Î¶¨Ïä§ÌÅ¨ ÌôïÏù∏
        for position in positions:
            self._check_position_risks(position)

        # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Ï†ÑÏ≤¥ Î¶¨Ïä§ÌÅ¨ ÌôïÏù∏
        self._check_portfolio_risks(positions)

    def _check_position_risks(self, position):
        """Í∞úÎ≥Ñ Ìè¨ÏßÄÏÖò Î¶¨Ïä§ÌÅ¨ ÌôïÏù∏"""

        symbol = position.symbol

        # 1. ÎßàÏßÑ ÎπÑÏú® ÌôïÏù∏
        self._check_margin_ratio(position)

        # 2. Ï≤≠ÏÇ∞Í∞Ä Í±∞Î¶¨ ÌôïÏù∏
        self._check_liquidation_distance(position)

        # 3. ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ ÌôïÏù∏
        self._check_unrealized_pnl(position)

        # 4. ADL ÏúÑÌóòÎèÑ ÌôïÏù∏
        self._check_adl_risk(position)

    def _check_margin_ratio(self, position):
        """ÎßàÏßÑ ÎπÑÏú® ÌôïÏù∏"""

        margin_ratio = position.margin_ratio
        symbol = position.symbol

        if margin_ratio >= self.thresholds['margin_ratio']['emergency']:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.EMERGENCY,
                metric=RiskMetric.MARGIN_RATIO,
                symbol=symbol,
                current_value=margin_ratio,
                threshold=self.thresholds['margin_ratio']['emergency'],
                message=f"üö® EMERGENCY: {symbol} margin ratio extremely high: {margin_ratio:.1%}",
                suggested_action="IMMEDIATE_POSITION_REDUCTION_OR_CLOSE",
                priority=10
            )
            self._handle_alert(alert)

        elif margin_ratio >= self.thresholds['margin_ratio']['critical']:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.CRITICAL,
                metric=RiskMetric.MARGIN_RATIO,
                symbol=symbol,
                current_value=margin_ratio,
                threshold=self.thresholds['margin_ratio']['critical'],
                message=f"‚ö†Ô∏è CRITICAL: {symbol} margin ratio high: {margin_ratio:.1%}",
                suggested_action="REDUCE_LEVERAGE_OR_POSITION_SIZE",
                priority=8
            )
            self._handle_alert(alert)

        elif margin_ratio >= self.thresholds['margin_ratio']['warning']:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.WARNING,
                metric=RiskMetric.MARGIN_RATIO,
                symbol=symbol,
                current_value=margin_ratio,
                threshold=self.thresholds['margin_ratio']['warning'],
                message=f"‚ö†Ô∏è WARNING: {symbol} margin ratio elevated: {margin_ratio:.1%}",
                suggested_action="MONITOR_CLOSELY",
                priority=5
            )
            self._handle_alert(alert)

    def _check_liquidation_distance(self, position):
        """Ï≤≠ÏÇ∞Í∞Ä Í±∞Î¶¨ ÌôïÏù∏"""

        if position.liquidation_price <= 0:
            return

        mark_price = position.mark_price
        liquidation_price = position.liquidation_price
        distance = abs(mark_price - liquidation_price) / mark_price
        symbol = position.symbol

        if distance <= self.thresholds['liquidation_distance']['emergency']:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.EMERGENCY,
                metric=RiskMetric.LIQUIDATION_DISTANCE,
                symbol=symbol,
                current_value=distance,
                threshold=self.thresholds['liquidation_distance']['emergency'],
                message=f"üö® LIQUIDATION IMMINENT: {symbol} only {distance:.1%} from liquidation",
                suggested_action="EMERGENCY_CLOSE_POSITION",
                priority=10
            )
            self._handle_alert(alert)

        elif distance <= self.thresholds['liquidation_distance']['critical']:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.CRITICAL,
                metric=RiskMetric.LIQUIDATION_DISTANCE,
                symbol=symbol,
                current_value=distance,
                threshold=self.thresholds['liquidation_distance']['critical'],
                message=f"‚ö†Ô∏è LIQUIDATION RISK: {symbol} {distance:.1%} from liquidation",
                suggested_action="REDUCE_POSITION_IMMEDIATELY",
                priority=9
            )
            self._handle_alert(alert)

    def _check_unrealized_pnl(self, position):
        """ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ ÌôïÏù∏"""

        pnl_percent = position.percentage / 100
        symbol = position.symbol

        if pnl_percent <= self.thresholds['unrealized_pnl']['emergency']:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.EMERGENCY,
                metric=RiskMetric.UNREALIZED_PNL,
                symbol=symbol,
                current_value=pnl_percent,
                threshold=self.thresholds['unrealized_pnl']['emergency'],
                message=f"üö® MAJOR LOSS: {symbol} unrealized loss: {pnl_percent:.1%}",
                suggested_action="CONSIDER_POSITION_CLOSE",
                priority=8
            )
            self._handle_alert(alert)

    def _check_adl_risk(self, position):
        """ADL (Auto-Deleveraging) ÏúÑÌóòÎèÑ ÌôïÏù∏"""

        # ADL ÏúÑÌóòÎèÑÎäî Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ÏôÄ ÏàòÏùµÎ•†Ïóê Îî∞Îùº Í≤∞Ï†ï
        # ÌÅ∞ Ìè¨ÏßÄÏÖòÏù¥Î©¥ÏÑú ÎÜíÏùÄ ÏàòÏùµÎ•†Ïùº Îïå ADL ÏúÑÌóò Ï¶ùÍ∞Ä

        position_size_usd = position.size * position.mark_price
        pnl_percent = position.percentage / 100

        # ÌÅ∞ Ìè¨ÏßÄÏÖò (>$50,000)Ïù¥Î©¥ÏÑú ÎÜíÏùÄ ÏàòÏùµ (>20%)
        if position_size_usd > 50000 and pnl_percent > 0.2:
            alert = RiskAlert(
                timestamp=datetime.now(),
                alert_level=AlertLevel.WARNING,
                metric=RiskMetric.ADL_RISK,
                symbol=position.symbol,
                current_value=pnl_percent,
                threshold=0.2,
                message=f"üìä ADL RISK: {position.symbol} large profitable position may face ADL",
                suggested_action="CONSIDER_PARTIAL_PROFIT_TAKING",
                priority=6
            )
            self._handle_alert(alert)

    def _check_portfolio_risks(self, positions):
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Ï†ÑÏ≤¥ Î¶¨Ïä§ÌÅ¨ ÌôïÏù∏"""

        if not positions:
            return

        # Ï¥ù ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ Í≥ÑÏÇ∞
        total_unrealized_pnl = sum(pos.unrealized_pnl for pos in positions)

        # Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå
        balance_info = self.position_manager.get_account_balance()
        total_balance = balance_info.get('total_wallet_balance', 0)

        if total_balance > 0:
            portfolio_pnl_percent = total_unrealized_pnl / total_balance

            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î†àÎ≤® ÏÜêÏã§ ÌôïÏù∏
            if portfolio_pnl_percent <= -0.2:  # -20% Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÜêÏã§
                alert = RiskAlert(
                    timestamp=datetime.now(),
                    alert_level=AlertLevel.CRITICAL,
                    metric=RiskMetric.PORTFOLIO_VAR,
                    symbol="PORTFOLIO",
                    current_value=portfolio_pnl_percent,
                    threshold=-0.2,
                    message=f"üö® PORTFOLIO LOSS: {portfolio_pnl_percent:.1%} total unrealized loss",
                    suggested_action="REVIEW_ALL_POSITIONS",
                    priority=9
                )
                self._handle_alert(alert)

    def _handle_alert(self, alert: RiskAlert):
        """ÏïåÎ¶º Ï≤òÎ¶¨"""

        # Ï§ëÎ≥µ ÏïåÎ¶º Î∞©ÏßÄ (Í∞ôÏùÄ Ïã¨Î≥º, Í∞ôÏùÄ Î©îÌä∏Î¶≠Ïùò ÏµúÍ∑º 5Î∂Ñ Ïù¥ÎÇ¥ ÏïåÎ¶º)
        if self._is_duplicate_alert(alert):
            return

        # ÏïåÎ¶º Í∏∞Î°ùÏóê Ï∂îÍ∞Ä
        self.alert_history.append(alert)

        # ÏµúÍ∑º 100Í∞ú ÏïåÎ¶ºÎßå Ïú†ÏßÄ
        if len(self.alert_history) > 100:
            self.alert_history = self.alert_history[-100:]

        # Î°úÍ∑∏ Í∏∞Î°ù
        if self.auto_actions['log_all_alerts']:
            logger.warning(f"RISK ALERT: {alert.message}")

        # ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º
        if self.auto_actions['send_telegram_alerts'] and self.telegram_bot:
            self._send_telegram_alert(alert)

        # ÏûêÎèô ÎåÄÏùë Ï°∞Ïπò
        self._execute_auto_actions(alert)

        # Ïª§Ïä§ÌÖÄ Ìï∏Îì§Îü¨ Ïã§Ìñâ
        for handler in self.notification_handlers:
            try:
                handler(alert)
            except Exception as e:
                logger.error(f"Alert handler error: {e}")

    def _is_duplicate_alert(self, alert: RiskAlert, window_minutes: int = 5) -> bool:
        """Ï§ëÎ≥µ ÏïåÎ¶º ÌôïÏù∏"""

        cutoff_time = datetime.now() - timedelta(minutes=window_minutes)

        for existing_alert in reversed(self.alert_history):
            if existing_alert.timestamp < cutoff_time:
                break

            if (existing_alert.symbol == alert.symbol and
                existing_alert.metric == alert.metric and
                existing_alert.alert_level == alert.alert_level):
                return True

        return False

    def _send_telegram_alert(self, alert: RiskAlert):
        """ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º Î∞úÏÜ°"""

        try:
            # ÏïåÎ¶º Î†àÎ≤®Ïóê Îî∞Î•∏ Ïù¥Î™®ÏßÄ
            level_emoji = {
                AlertLevel.INFO: "‚ÑπÔ∏è",
                AlertLevel.WARNING: "‚ö†Ô∏è",
                AlertLevel.CRITICAL: "üö®",
                AlertLevel.EMERGENCY: "üÜò"
            }

            emoji = level_emoji.get(alert.alert_level, "üìä")

            message = f"{emoji} RISK ALERT\n\n"
            message += f"Symbol: {alert.symbol}\n"
            message += f"Metric: {alert.metric.value}\n"
            message += f"Level: {alert.alert_level.value}\n"
            message += f"Current: {alert.current_value:.3f}\n"
            message += f"Threshold: {alert.threshold:.3f}\n\n"
            message += f"Message: {alert.message}\n"
            message += f"Action: {alert.suggested_action}\n"
            message += f"Time: {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S')}"

            self.telegram_bot.send_message(message)

        except Exception as e:
            logger.error(f"Telegram alert failed: {e}")

    def _execute_auto_actions(self, alert: RiskAlert):
        """ÏûêÎèô ÎåÄÏùë Ï°∞Ïπò Ïã§Ìñâ"""

        if alert.alert_level == AlertLevel.EMERGENCY:

            # Í∏¥Í∏â ÏÉÅÌô© Ïãú Ìè¨ÏßÄÏÖò ÏûêÎèô Í∞êÏÜå ÎòêÎäî Ï≤≠ÏÇ∞
            if (self.auto_actions['close_position_on_emergency'] and
                alert.metric in [RiskMetric.MARGIN_RATIO, RiskMetric.LIQUIDATION_DISTANCE]):

                try:
                    if alert.metric == RiskMetric.LIQUIDATION_DISTANCE:
                        # Ï≤≠ÏÇ∞ ÏúÑÌóò Ïãú Ï¶âÏãú Ï†ÑÏ≤¥ Ï≤≠ÏÇ∞
                        self.position_manager.close_position(alert.symbol, 100)
                        logger.warning(f"üö® EMERGENCY AUTO-CLOSE: {alert.symbol} position closed")
                    else:
                        # ÎßàÏßÑ ÏúÑÌóò Ïãú 50% Í∞êÏÜå
                        self.position_manager.close_position(alert.symbol, 50)
                        logger.warning(f"‚ö†Ô∏è EMERGENCY AUTO-REDUCE: {alert.symbol} position reduced by 50%")

                except Exception as e:
                    logger.error(f"Auto-action failed for {alert.symbol}: {e}")

        elif alert.alert_level == AlertLevel.CRITICAL:

            # Ïã¨Í∞ÅÌïú ÏÉÅÌô© Ïãú Ìè¨ÏßÄÏÖò Î∂ÄÎ∂Ñ Í∞êÏÜå
            if (self.auto_actions['reduce_position_on_critical'] and
                alert.metric == RiskMetric.MARGIN_RATIO):

                try:
                    self.position_manager.close_position(alert.symbol, 25)
                    logger.warning(f"‚ö†Ô∏è AUTO-REDUCE: {alert.symbol} position reduced by 25%")
                except Exception as e:
                    logger.error(f"Auto-reduction failed for {alert.symbol}: {e}")

    def add_notification_handler(self, handler: Callable[[RiskAlert], None]):
        """Ïª§Ïä§ÌÖÄ ÏïåÎ¶º Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä"""
        self.notification_handlers.append(handler)

    def get_risk_summary(self) -> Dict:
        """Î¶¨Ïä§ÌÅ¨ ÏöîÏïΩ Ï†ïÎ≥¥"""

        positions = self.position_manager.get_position_info()
        if not positions:
            return {"status": "no_positions"}

        # Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®Î≥Ñ Ìè¨ÏßÄÏÖò Î∂ÑÎ•ò
        risk_levels = {"LOW": 0, "MEDIUM": 0, "HIGH": 0, "CRITICAL": 0}
        total_unrealized_pnl = 0

        for position in positions:
            risk_levels[position.risk_level] += 1
            total_unrealized_pnl += position.unrealized_pnl

        # ÏµúÍ∑º ÏïåÎ¶º ÌÜµÍ≥Ñ
        recent_alerts = [a for a in self.alert_history
                        if a.timestamp > datetime.now() - timedelta(hours=24)]
        alert_counts = {}
        for level in AlertLevel:
            alert_counts[level.value] = len([a for a in recent_alerts
                                           if a.alert_level == level])

        return {
            'monitoring_active': self.monitoring,
            'total_positions': len(positions),
            'risk_distribution': risk_levels,
            'total_unrealized_pnl': total_unrealized_pnl,
            'recent_alerts_24h': alert_counts,
            'last_check': datetime.now().isoformat()
        }

    def generate_risk_report(self) -> str:
        """Î¶¨Ïä§ÌÅ¨ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±"""

        summary = self.get_risk_summary()

        report = "üõ°Ô∏è RISK MONITORING REPORT\n"
        report += "=" * 50 + "\n\n"

        if summary.get('status') == 'no_positions':
            report += "‚úÖ No active positions - No risk exposure\n"
            return report

        # Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú
        status_emoji = "üü¢" if summary['monitoring_active'] else "üî¥"
        report += f"{status_emoji} Monitoring Status: {'ACTIVE' if summary['monitoring_active'] else 'INACTIVE'}\n\n"

        # Ìè¨ÏßÄÏÖò Î¶¨Ïä§ÌÅ¨ Î∂ÑÌè¨
        report += "üìä POSITION RISK DISTRIBUTION:\n"
        risk_dist = summary['risk_distribution']
        for level, count in risk_dist.items():
            if count > 0:
                emoji = {"LOW": "üü¢", "MEDIUM": "üü°", "HIGH": "üü†", "CRITICAL": "üî¥"}[level]
                report += f"   {emoji} {level}: {count} positions\n"

        # Ï¥ù ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ
        pnl = summary['total_unrealized_pnl']
        pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
        report += f"\n{pnl_emoji} Total Unrealized PnL: ${pnl:.2f}\n\n"

        # ÏµúÍ∑º ÏïåÎ¶º ÌÜµÍ≥Ñ
        report += "üö® RECENT ALERTS (24h):\n"
        alert_counts = summary['recent_alerts_24h']
        total_alerts = sum(alert_counts.values())

        if total_alerts == 0:
            report += "   ‚úÖ No alerts in the last 24 hours\n"
        else:
            for level, count in alert_counts.items():
                if count > 0:
                    emoji = {"INFO": "‚ÑπÔ∏è", "WARNING": "‚ö†Ô∏è", "CRITICAL": "üö®", "EMERGENCY": "üÜò"}[level]
                    report += f"   {emoji} {level}: {count} alerts\n"

        report += f"\nüìÖ Report Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"

        return report